Checks:

head –n 12 t21rep1_1.fastq 

Line 1 contains the sequence identifier, which is unique for each read
 Line 2 is DNA sequence
 Line 3 is usually unused and either has “+” or a repeat of the sequence ID
 Line 4 is the Phred quality score in ASCII format, which is often specially formated
depending on the sequencing platform


wc –l t21rep1_* // Count the number of lines in the read files

sed –n ‘2p’ t21rep1_1.fastq | wc –m // Finds the read length
// There are 50 bases, but this command also counts the newline



---- Formats

Sequence Alignment/Map (SAM/BAM) Format

------

Build the index:

bowtie2-build Mus_chr19.fa Mus_chr19 // Create the Mus_chr19 


---- Aligning using TopHat

+ tophat_command <- paste("tophat -p 4 -g 1 --segment-length 15 -i 30 -I 3000 -o ", output[i], ".tophat ", reference, " ", input[i], sep="")

+ # -G: supply GFF with transcript model info (preferred!)

+ # -g: ignore all alginments with >g matches

+ # -p: number of threads to use for alignment step

+ # -i/-I: min/max intron lengths

+ # --segment-length: length of split reads (25 is default)


-------
Check after:

A good way to view mapping statistics from tophat runs is to check the mapping logs. From
within the \tophat_out directory, navigate to the logs sub-directory and browse metrics for the R1
(left) and R2 (right) reads.
cd logs // Enter the logs sub-directory
ls –la // See all of the various log files created
cat bowtie.left_kept_reads.log // Check the R1 mapping metrics
cat bowtie.right_kept_reads.log // Check the R2 mapping metrics


Example metrics:
 754050 reads; of these:
 754050 (100.00%) were unpaired; of these:
o 215516 (28.58%) aligned 0 times
o 486843 (64.56%) aligned exactly 1 time
o 51691 (6.86%) aligned >1 times
 71.42% overall alignment rate
cd ../ // Go back to the ‘tophat_out’ directory
// Look for ‘align_summary.txt’ to get an idea of alignment statistics of paired reads
cd ../ // Go back to the ‘Working_space’ directory


---- STEP 3: USING CUFFLINKS TO IDENTIFY DGE

cufflinks -G Mus_chr19.gtf t21rep1.bam

head –n 20 transcripts.gtf // See the cufflinks output


--- MERGING CUFFLINKS OUTPUT WITH CUFFMERGE

cuffmerge -g Mus_chr19.gtf assembly_list.txt
< assembly_list.txt is a text file that needs to be made >


ls | grep -Po "t.+rep..gtf" > assembly_list.txt
cat assembly_list.txt // See the necessary formatting of this file
// This file tells cuffmerge which .gtfs to use for analysis

head –n 15 merged.gtf // Browse the combined .gtf file


---- QUANTIFYING GENE/TRANSCRIPT EXPRESSION USING CUFFQUANT

cuffquant -o ./t21rep1_cfquant merged.gtf t21rep1.bam
mv abundances.cxb ../t21rep1.cxb


--- IDENTIFYING DGE USING CUFFDIFF

cuffdiff -v merged.gtf -L t7,t21 t7rep1.cxb,t7rep2.cxb,t7rep3.cxb t21rep1.cxb,t21rep2.cxb,t21rep3.cxb

// -v specifies the cuffmerge output file
// -L gives text labels to the treatments being compared
// The final list of .cxb files generated by Cuffquant:
// Within a treatment, replicates are separated by commas
// Treatment groups are separated by a space




-----
Column | Column name | Example | Description
--- | --- | --- | --- 
1 | Tested id |  XLOC_000001 | A unique identifier describing the transcipt, gene, primary transcript, or CDS being tested
2 | gene id |  XLOC_000001 | A unique identifier describing the transcipt, gene, primary transcript, or CDS being tested
3 | gene | Lypla1 | The gene_name(s) or gene_id(s) being tested
4 locus chr1:4797771-4835363 Genomic coordinates for easy browsing to the genes or transcripts being tested.
5 | sample 1 | Liver | Label (or number if no labels provided) of the first sample being tested 
6 | sample 2 | Brain | Label (or number if no labels provided) of the second sample being tested
7 | Test status | NOTEST | Can be one of OK (test successful), NOTEST (not enough alignments for testing), LOWDATA (too complex or shallowly sequenced), HIDATA (too many fragments in locus), or FAIL, when an ill-conditioned covariance matrix or other numerical exception prevents testing. 
8 | FPKMx | 8.01089 | FPKM of the gene in sample x
9 | FPKMy | 8.551545 | FPKM of the gene in sample y 
10 | log2(y/x) | 0.06531 | The (base 2) log of the fold change y/x
11 | test stat | 0.860902 |The value of the test statistic used to compute significance of the observed change in FPKM 
12 | p value | 0.389292 | The uncorrected p-value of the test statistic
13 | q value | 0.985216 | The FDR-adjusted p-value of the test statistic 14 significant no Can be either "yes" or "no", depending on whether p is greater then the FDR after Benjamini-Hochberg correction for multiple-testing



---- STEP 4: MAKING THE COUNTS MATRIX using HTSeq

samtools sort -n t21rep1.bam t21rep1_sorted
// Sort the .bam file
samtools view t21rep1_sorted.bam > t21rep1.sam
// Convert to .sam file

htseq-count -q -m union -s no -t exon -i gene_id t21rep1.sam Mus_chr19.gtf > t21rep1.counts


head –n 30 t21rep1.counts // Observe the how the counts are stored
tail –n 10 t21rep1.counts // See why counts were lost
no_feature 160506 // Aligned in non-gene region ambiguous 17416 // Aligned in region with 2 genes too_low_aQual 0 // Quality is too poor not_aligned 0 // No alignment found alignment_not_unique 616529 // Aligned to many places



CREATE Matrix::

The following commands generate the combined matrix >
echo -e "Genes\tt7r1\tt7r2\tt7r3\tt21r1\tt21r2\tt21r3" > matrix.part1
paste t7rep*.counts t21rep*.counts > matrix.part2
cut -f 1,2,4,6,8,10,12 matrix.part2 > matrix.part3
cat matrix.part1 matrix.part3 > counts_matrix.txt
< The complete matrix is counts_matrix.txt >
head counts_matrix.txt // View the top of the matrix
wc –l counts_matrix.txt
// Count number of lines in file.971 lines are present
sed ‘967,971d’ < counts_matrix.txt > counts_matrix_final.txt // Remove last 5 lines of HTSeq statistics information from the file


---- IGV

samtools index yeast_1_50K_star_Aligned.sortedByCoord.out.bam
$ samtools index yeast_12_50K_star_Aligned.sortedByCoord.out.bam

1) Load IGV

2) Load Genome from FASTA (*.fa) file

3) Load annotations from GTF file

4) Load one/two indexed alignment file form *.bam file


--- Count using featureCount

http://bioinf.wehi.edu.au/featureCounts/


Summarize a single-end read dataset using 5 threads:
featureCounts -T 5 -t exon -g gene_id -a annotation.gtf -o counts.txt mapping_results_SE.sam
Summarize a BAM format dataset:
featureCounts -t exon -g gene_id -a annotation.gtf -o counts.txt mapping_results_SE.bam
Summarize multiple datasets at the same time:
featureCounts -t exon -g gene_id -a annotation.gtf -o counts.txt library1.bam library2.bam library3.bam
Perform strand-specific read counting (use '-s 2' if reversely stranded):
featureCounts -s 1 -t exon -g gene_id -a annotation.gtf -o counts.txt mapping_results_SE.bam
Summarize paired-end reads and count fragments (instead of reads):
featureCounts -p -t exon -g gene_id -a annotation.gtf -o counts.txt mapping_results_PE.bam
Summarize multiple paired-end datasets:
featureCounts -p -t exon -g gene_id -a annotation.gtf -o counts.txt library1.bam library2.bam library3.bam
Count the fragments that have fragment length between 50bp and 600bp only:
featureCounts -p -P -d 50 -D 600 -t exon -g gene_id -a annotation.gtf -o counts.txt mapping_results_PE.bam
Count those fragments that have both ends mapped only:
featureCounts -p -B -t exon -g gene_id -a annotation.gtf -o counts.txt mapping_results_PE.bam
Exclude chimeric fragments from fragment counting:
featureCounts -p -C -t exon -g gene_id -a annotation.gtf -o counts.txt mapping_results_PE.bam

